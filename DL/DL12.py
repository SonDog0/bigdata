# 마르코프 체인
# 구글의 검색 알고리즘인 페이지 랭크는
# 마르코프 모델을 사용하고 있음 - 데이터 과학에서는 필수 !

# 마르코프 성질
# 과거와 현재의 상태가 주어졌을때
# 미래의 상태는 조건부확률(나이브베이즈)에 의해
# 현재 상태에 의해서만 결정된다는 이론

# 확률변수가 어떤 상태에 도달할 확률은
# 오직 바로 이전 시점의 상태에 달려있음

# 예 ) 영화 터미네이터를 보면
# 미래에 일어날 일을 막기위해
# 과거의 원인을 제거하기 위해 누군가가 미래에서 찾아옴
# => 과거에 뭔가 일어났기 때문에 미래에 그것이 발생

# 예2 ) 오늘 회사에 지각했음
# => 원인 : 전날 음주
# => 음주 원인 : 여친과 결별 또는 시험 탈락
# => 여친결별원인 : 싸움
# => 원인.....

# 따라서, 오늘 이런일이 일어난 이유가
# 과거의 유한한 몇몇일들(!) 때문이 아니고
# 과거의 유한한 일(1) 떄문이라고 생각해 봄

# 예3) 회사에 눈여겨 본 여사원이 있는데
# 그녀가 어제 나에게 미소를 지었는데
# 오늘 역시 나에게 미소를 지어줄 확률은 ?
# 그녀의 전날 기분에 따라 미소를 지어줄 확률이 결정
# =>전날의 기분 => 전전날의 기분 => ...
# 기분의 관계가 사슬처럼 연결 되어 있음 => 체인

# 예4 ) 게임기를 생산하는 회사 M이
# 광고를 전개해서 점유율을 높이려고 함
# 이 회사의 점유율이 20%라고 할때
# 광고를 보고 다른 브랜드 게임기를 사용한 고객이
# 전환할 확률이 0.7 , 광고를 보고 기존 브랜드를 고수할 확률이 0,3
# 기존 브랜드를 사용한 고객이 기존 브랜드를 고수할 확률이 0.9, 다른 브랜드로 갈아탈 확률이  0.1 이라고 할때
# 광고의 효과를 유추해본다면 ?

# 회사점유율 * [광고효과확률]
# => [0.2 0.8] * [ 0.7 0.3 ]
#                [ 0.9 0.1 ]
# => [ 0.2 * 0.7 + 0.8 * 0.9  , 0.2 * 0.3 + 0.8 * 0.1 ]
# => [ 0.14 + 0.72 ,  0.6 + 0.8 ] => [ 0.86  0.14 ]

# => [ 0.86  0.14 ] * [ 0.7 0.3 ]
#                     [ 0.9 0.1 ]
# =====> [0.87 0.125]   # 일정 수준까지 도달하면 더이상 올라가지 않음

# 마르코프 체인은 확률적 오토마톤을 사용해서 표현
# 시스템 상태의 변화를 전이transition라고 하는데
# 다양한 사태변화와 관련된 확률을 전이 확률이라 함

# 오토마톤(automaton) : 인간의 지속적인 조정없이
# 스스로 작동하는 기계를 의미하는 말

# mc_state_dg 참고
# 어떤 여성이 실연을 당해 잠을 잤을때,
# 2일후 이 여성이 달리고 있을 확률은?
# 1) sleep -> sleep(0.2) -> run(0.6)
# 2) run -> run(0.6) -> run(0.6)
# 3) sleep -> icecream(0.2) -> run(0.7)

# 따라서, 0.2*0.6 + 0.6*0.6 + 0.2*0.7
# => 0.12 + 0.36 + 0.14 => 0.62
# 2일후 이 여성이 달리고 있을 확률 : 0.62%




# mc_state_stockmarket 참고
# 증권시장은 주별로
# bull(강세) / bear(약세) / stagnant(침체) 등으로 구분
# 현재 침체기인데 3일후 강세시장이 될 확률은?
# 채팅 봇으로 만들어 봄

# '그는 고양이를 좋아합니다.' 라는 문장을
# 형태소 분석후 3개의 요소로 묶어 dict 형으로 저장
# 그|는 고양이
# 는 고양이|를
# 고양이|를 좋아|합니다|.
# 를 좋아|합니다|.

from konlpy.tag import Okt
import json

text = ['안녕하세요, 저는 수지라고 해요.',
        '오늘 날씨가 정말로 좋은것 같지 않아요?',
        '그는 고양이를 좋아합니다.',
        '개도 닷새가 되면 주인을 안다.',
        '기르던 개에게 다리가 물렸다.',
        '닭 쫓던 개 지붕 쳐다 보듯 한다.',
        '똥 묻은 개가 겨 묻은 개 나무란다.']


text2 = '안녕하세요, 저는 수지라고 해요.\
        오늘 날씨가 정말로 좋은것 같지 7않아요?\
        그는 고양이를 좋아합니다.\
        개도 닷새가 되면 주인을 안다.\
        기르던 개에게 다리가 물렸다.\
        닭 쫓던 개 지붕 쳐다 보듯 한다.\
        똥 묻은 개가 겨 묻은 개 나무란다.'



# 마르코프 체인 사전 만들기
def make_dic(words):
    tmp = ['@'] # @는 문장의 시작을 의미하는 기호
    dic = {}
    for word in words:
        tmp.append(word)
        if len(tmp) < 3 : continue # 단어가 3개 모일때 까지 반복 실행
        if len(tmp) > 3 : tmp = tmp[1:] # 단어가 3개 모이면 단어사전에 등록
        # print(tmp)
        set_word3(dic,tmp)
        # if word == '.' : # 문장 처리가 끝나면 다음 처리를 위해 초기화
        #     tmp = ['@']
        #     continue

    return dic



# 사전에 데이터 등록하기 (문장 길이: 3 )
def set_word3 (dic , s3):
    w1 , w2, w3 = s3
    if w1 not in dic : # 단어 사전에 등록되지 않았다면
        dic[w1] = {} # dic 사전형에 w1 키값을 비워둠
    if w2 not in dic[w1] :
        dic[w1][w2] = {} # 변수dic w1 키값 안에 w2 키값을 생성
    if w3 not in dic[w1][w2]:
        dic[w1][w2][w3] = 0

    dic[w1][w2][w3] += 1 # 단어 묶음 중 마지막 단어에 다음언어로 이동할 확률을 명시



twitter = Okt()
mallist = {}

# for i in range(0,len(text)):
#     malist =  twitter.pos(text[i] , norm = True)
#     # print(malist)
#     words = []
#     for word in malist:
#         if word[1] not in ['Punctuation']: # 문장부호 제외
#             words.append(word[0])
#         if word[0] == '.' : # 마침표 등록
#             words.append(word[0])
#         if word[0] == '?':  # 마침표 등록
#             words.append(word[0])
#     # print(words)
#     dic = make_dic(words)
# #
#     print(dic)


# text2를 형태소 분석 및 사전 생성

malist =  twitter.pos(text2 , norm = True)

words = []
for word in malist:
    if word[1] not in ['Punctuation']: # 문장부호 제외
        words.append(word[0])
    if word[0] == '.' : # 마침표 등록
        words.append(word[0])
    if word[0] == '?':
        words.append(word[0])
# print(words)
dic = make_dic(words)

print(dic)



# # 생성된 사전을 파일로 저장함
# # 파일로 저장시 dict형식이 유지되어야 함 => 직렬화
# json.dump(dic,open('c:/java/data/dic.json' ,'w' , encoding='utf-8'))

