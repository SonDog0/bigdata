# 활성화 함수activation func
# 신경망 개별 뉴런에 들어오는 입력신호의 총합을
# 출력신호로 변환하는 함수

# 퍼셉트론에는 없었지만 신경망에서 도입하기 시작
# 대게 선형함수가 아닌 비선형 함수를 함수로 사용
# 종류는 sigmoid , relu , tanh , softmax

# 퍼셉트론 행렬연산 예 (pdf 3page 그림 )
# 입력값 : x1 , x2 = 1.0 , 0.5
# 가중치 : w1 , w2 , w3, w4 = 0.9 , 0.2 0.3, 0.8
# 첫번째 노드 출력값 : 1.0 * 0.9 + 0.5 * 0.3  = 1.05 (가중치 X : 1.5)

# 좀 더 나은 신경망 학습을 위해
# 활성화 함수를 통해서 노드 출력값을 조정함
# 시그모이드 함수  : y = 1 / (1+e **-x )

# 첫번째 출력 노드값 ( 활성화함수 )
# y = 1 / (1+2.17828 ** 1.05 ) = 1 / (1 + 0.3499) = > 0.7408
import numpy as np
x = 1.05
print(1/ ( 1 + np.e ** -x))
# 0.7408

# 두번째 출력 노드값
x = 0.2 + 0.4
print(1/ ( 1 + np.e ** -x))


# 딥러닝의 훈련 : 역전파를 통해 적절한 가중치 및 편향을 찾는것
# 지금까지 수작업으로 다중 퍼셉트론에 전달디는 값에
# 대한 결과값을 계산하였음
# 한편, 복잡하게 구성되는 다층 퍼셉트론에서는
# 이러한 수작업은 불가능에 가까움

# 수 많은 계층과 노드들을 가지는 복잡한 신경망의 계산은
# 매우 간결하게 출력값을 구할 수 있는 수학적 방법이 필요
# => 간결한 접근 방법을 제공하는것 : 행렬 (벡터) 연산

# 신경망의 각 노드의 입력값 / 가중치는 벡터로 표현
# 입력노드값 = [0.5 , 0.1 , 0.8]
# 입력노드 가중치 = []
# 은닉충 가중치 = []

# numpy 행렬값 출력 형식 지정 : 소수 셋째짜리
# np.set_printoptions(precision=3)
np.set_printoptions(formatter={'float' :'{:.3f}'.format})

# 입력값
X = np.array([1.0 , 0.5])
W = np.array([[0.9 , 0.3] , [0.2,0.8]])
Y = np.dot(W,X)
print(Y)

print(type(Y))
# 시그모이드 함수 정의
def sigmoid(x):
    try:
        # 입려력값이 행렬이라면
        for i in range(0,len(x)):
            x[i] = 1 / (1 + np.e ** -x[i])

    except:
        # 입력값이 단일값이라면
        x = 1 / (1 + np.e ** -x )

    return x

print('시그모이드 결과 %.4f' % sigmoid(1.05))


# 내적을 구한 값을 활성화 함수에 적용
# print('%.4f' % sigmoid(Y))

# pdf page 6 예제
# 입력층, 은닉층 , 출력층으로 구성된 신경망에서
# 입력값과 가중치의 활성화 함수 계산과정을
# 행렬로 표현해서 알아봄



# 열우선
# X = np.array([0.9,0.1,0.8])
# W1 = np.array([[0.9,0.2,0.1] , [0.3,0.8,0.5] , [0.4,0.2,0.6]])
#
# W2 =np.array([[0.3,0.6,0.8] , [0.7,0.5,0.1] , [0.5,0.2,0.9]])
#
# # 입력층에서 은닉충 순전파
# Y1 = np.dot(X,W1)
# print('입력 -> 은닉' , Y1)
# print(sigmoid(Y1))
# # 은닉충에서 출력층 순전파
# Y2 = np.dot(Y1,W2)
# print('은닉-> 출력' , Y2)
# print(sigmoid(Y2))


# 행우선 ( 행렬 정의가 달라짐 )

X = np.array([0.9,0.1,0.8])
W1 = np.array([[0.9,0.3,0.4] , [0.2,0.8,0.2] , [0.1,0.5,0.6]])
W2 =np.array([[0.3,0.7,0.5] , [0.6,0.5,0.2] , [0.8,0.1,0.9]])

# 입력층에서 은닉충 순전파 (dot의 파라미터 순서가 바뀜 (열우선과 비교 )
Y1 = np.dot(W1,X)
print('입력 -> 은닉' , Y1)
print(sigmoid(Y1))
# 은닉충에서 출력층 순전파
Y2 = np.dot(W2,Y1)
print('은닉-> 출력' , Y2)
print(sigmoid(Y2))


